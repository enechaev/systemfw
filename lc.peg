# typed lambda calculus

%prefix "lc"
%value "union lt"
%auxil "struct ctx *"
%header {
    #include "context.h" 
    #include "lambda.h" 
    #include "type.h"
    #include "debruijn.h"
    extern struct type *infertype(struct lambda *,struct context *D);

    struct ctx {
        struct debruijn db;
        struct context ctx;
    };

    union lt {
        struct lambda *l;
        struct type *t;
    };
}
%source {
    #ifndef PCC_ERROR
    #define PCC_ERROR(auxil) pcc_error(auxil)
    static void pcc_error(struct ctx *auxil) {
        fprintf(stderr, "Syntax error\n");
        if(auxil) debruijn_destroy(auxil->db);
        exit(1);
    }
    #endif /* PCC_ERROR */
}

main        <- S:sentence {$$=S;} (SEP S:sentence {$$=S;})* SEP?
sentence    <- ID:ID EQUAL T:term {context_add(&auxil->ctx,ID.l->atom.s,NULL,T.l); free(ID.l); $$=T; printcontext(&auxil->ctx);}
             / _ '?' EQUAL T:term {struct type *t; printtype(t=infertype(T.l,&auxil->ctx)); $$=T;}
term        <- (T:application / T:abstraction) {$$=T;}
abstraction <- LAMBDA ID:ID (OFTYPE TID:tterm)? {if (indexof(&auxil->db,ID.l->atom.s)) PCC_ERROR(auxil); debruijn_push(&auxil->db,ID.l->atom.s);}
                            DOT T:term {
                                        debruijn_pop(&auxil->db);
                                        $$.l=(struct lambda *)malloc(sizeof(struct lambda));
                                        if (!$$.l) PCC_ERROR(auxil);
                                        $$.l->t=LAMBDA_ABSTR;
                                        $$.l->abstr.v=ID.l->atom.s; free(ID.l);
                                        $$.l->abstr.type=TID.t;
                                        $$.l->abstr.expr=T.l;
                                      }
application <- S:application T:atom {
                                        $$.l=(struct lambda *)malloc(sizeof(struct lambda));
                                        if (!$$.l) PCC_ERROR(auxil);
                                        $$.l->t=LAMBDA_APPL;
                                        $$.l->appl.lhs=S.l;
                                        $$.l->appl.rhs=T.l;
                                    }
             / T: atom {$$=T;}
atom        <- ID:ID {$$=ID;}
             / LP T:term RP {$$=T;}
ID          <- _ <[A-Za-z/_*+-][A-Za-z0-9/_*+-]*> _ {
                                                $$.l=(struct lambda *)malloc(sizeof(struct lambda));
                                                if (!$$.l) PCC_ERROR(auxil);
                                                $$.l->t=LAMBDA_ATOM;
                                                $$.l->atom.s=strdup($1);
                                                if (!$$.l->atom.s) PCC_ERROR(auxil);
                                                $$.l->atom.index=indexof(&auxil->db,$1);
                                           }
tterm       <- T:tatom {$$=T;} (ARROW S:tterm {$$.t=type_function(T.t,S.t);})? 
tatom       <- ID:ID {
                    $$.t=mktype(TYPE_NAME,ID.l->atom.s,0); free(ID.l);
                    if (!$$.t) PCC_ERROR(auxil);
                }
             / LP T:tterm RP {$$=T;}
SEP         <- _ ';' _
EQUAL       <- _ '=' _
ARROW       <- _ '->' _
LAMBDA      <- _ '\\' _
OFTYPE      <- _ ':' _
DOT         <- _ '.' _
LP          <- _ '(' _
RP          <- _ ')' _
_           <- [\n\t\r ]*

