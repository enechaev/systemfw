# typed lambda calculus

%prefix "lc"
%value "union lt"
%auxil "struct ctx *"
%header {
    #include "context.h" 
    #include "lambda.h" 
    #include "type.h"
    #include "debruijn.h"
    extern struct type *infertype(struct lambda *,struct context *D);

    struct ctx {
        struct debruijn db;
        struct debruijn type_db;
        struct context ctx;
    };

    union lt {
        struct lambda *l;
        struct type *t;
        char *s;
    };

    struct ctx ctx_init();
    void ctx_destroy(struct ctx *);
}
%source {
    #ifndef PCC_ERROR
    #define PCC_ERROR(auxil) pcc_error(auxil)
    static void pcc_error(struct ctx *auxil) {
        fprintf(stderr, "Syntax error\n");
        if(auxil) ctx_destroy(auxil);
        exit(1);
    }
    #endif /* PCC_ERROR */
    struct ctx ctx_init() {
        struct ctx c;
        c.db=debruijn_init();
        c.type_db=debruijn_init();
        c.ctx=context_init();
        return c;
    }
    void ctx_destroy(struct ctx *c) {
        debruijn_destroy(c->db);
        debruijn_destroy(c->type_db);
        context_destroy(c->ctx);
    }
}

main        <- S:sentence {/*$$=S;*/} (SEP S:sentence {/*$$=S;*/})* SEP?
sentence    <- ID:ID EQUAL T:term {context_addterm(&auxil->ctx,ID.s,NULL,T.l); /*$$=T;*/ printcontext(&auxil->ctx);}
             / _ '?' EQUAL T:term {struct type *t; /*printnode(T.l); putchar('\n');*/ printtype(t=infertype(T.l,&auxil->ctx)); destroynode(T.l); destroytype(t); putchar('\n');/*$$=T;*/}
             / _ ':' ID:ID EQUAL T:tterm {context_addtype(&auxil->ctx,ID.s,T.t); /*$$=T;*/ printcontext(&auxil->ctx);}
term        <- (T:application / T:abstraction) {$$=T;}
abstraction <- LAMBDA ID:ID OF TID:tterm {if (indexof(&auxil->db,ID.s) || context_findterm(&auxil->ctx,ID.s)) PCC_ERROR(auxil); debruijn_push(&auxil->db,ID.s);} #forced Church style to allow type inference
                            DOT T:term {
                                        debruijn_pop(&auxil->db);
                                        $$.l=(struct lambda *)malloc(sizeof(struct lambda));
                                        if (!$$.l) PCC_ERROR(auxil);
                                        $$.l->t=LAMBDA_ABSTR;
                                        $$.l->abstr.v=ID.s;
                                        $$.l->abstr.overtype=false;
                                        $$.l->abstr.type=TID.t;
                                        $$.l->abstr.expr=T.l;
                                      }
             / UCLAMBDA ID:ID (OF K:tkind)? {if (indexof(&auxil->type_db,ID.s) /* || context_findtype(auxil->ctx,ID.s)*/) PCC_ERROR(auxil); debruijn_push(&auxil->type_db,ID.s);}
                               DOT T:term {
                                            debruijn_pop(&auxil->type_db);
                                            $$.l=(struct lambda *)malloc(sizeof(struct lambda));
                                            if (!$$.l) PCC_ERROR(auxil);
                                            $$.l->t=LAMBDA_ABSTR;
                                            $$.l->abstr.v=ID.s;
                                            $$.l->abstr.overtype=true;
                                            $$.l->abstr.type=NULL; //$$.l->abstr.kind=K;
                                            $$.l->abstr.expr=T.l;
                                          }
application <- S:application {
                                 $$.l=(struct lambda *)malloc(sizeof(struct lambda));
                                 if (!$$.l) PCC_ERROR(auxil);
                                 $$.l->t=LAMBDA_APPL;
                                 $$.l->appl.lhs=S.l;
                             } (T:atom {$$.l->appl.overtype=false; $$.l->appl.rhs.l=T.l;}
                               / LB TT:tterm RB {$$.l->appl.overtype=true; $$.l->appl.rhs.t=TT.t;})
             / T: atom {$$=T;}
atom        <- ID:ID {
                        $$.l=(struct lambda *)malloc(sizeof(struct lambda));
                        if (!$$.l) PCC_ERROR(auxil);
                        $$.l->t=LAMBDA_ATOM;
                        $$.l->atom.s=ID.s;
                        $$.l->atom.index=indexof(&auxil->db,ID.s);
                     }
             / LP T:term RP {$$=T;}
ID          <- _ <[A-Za-z_+][A-Za-z0-9_+]*> _ {
                                                $$.s=strdup($1);
                                                if (!$$.s) PCC_ERROR(auxil);
                                              }
tkind       <- UKIND
tterm       <- T:tatom {$$=T;} (ARROW S:tterm {$$.t=type_function(T.t,S.t);})?
tatom       <- ID:ID {
                    $$.t=mktype(TYPE_NAME,ID.s,0);
                    $$.t->index=indexof(&auxil->type_db,ID.s);
                    if (!$$.t) PCC_ERROR(auxil);
                }
             / LP T:tterm RP {$$=T;}
             / FORALL ID:ID (OF K:tkind)? {if (indexof(&auxil->type_db,ID.s)) PCC_ERROR(auxil); debruijn_push(&auxil->type_db,ID.s);}
                             DOT T:tterm {
                                            debruijn_pop(&auxil->type_db);
                                            $$.t=type_poly(ID.s,T.t);
                                         }
UCLAMBDA    <- _ ('/\\' / '\u039b') _
UKIND       <- _ '*' _
FORALL      <- _ ('\\/' / '\u2200') _
SEP         <- _ ';' _
EQUAL       <- _ '=' _
ARROW       <- _ ('->' / '\u2192') _
LAMBDA      <- _ ('\\' / '\u03bb') _
OF          <- _ ':' _
DOT         <- _ '.' _
LP          <- _ '(' _
RP          <- _ ')' _
LB          <- _ '[' _
RB          <- _ ']' _
_           <- [\n\t\r ]*

