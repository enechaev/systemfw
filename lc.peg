# typed lambda calculus

%prefix "lc"
%value "union lt"
%auxil "struct ctx *"
%header {
    #include "context.h" 
    #include "lambda.h" 
    #include "type.h"
    #include "debruijn.h"
    extern struct type *infertype(struct lambda *,struct context *D);

    struct ctx {
        struct debruijn db;
        struct context ctx;
    };

    union lt {
        struct lambda *l;
        struct type *t;
        char *s;
    };
}
%source {
    #ifndef PCC_ERROR
    #define PCC_ERROR(auxil) pcc_error(auxil)
    static void pcc_error(struct ctx *auxil) {
        fprintf(stderr, "Syntax error\n");
        if(auxil) {
            debruijn_destroy(auxil->db);
            context_destroy(auxil->ctx);
        }
        exit(1);
    }
    #endif /* PCC_ERROR */
}

main        <- S:sentence {$$=S;} (SEP S:sentence {$$=S;})* SEP?
sentence    <- ID:ID EQUAL T:term {context_add(&auxil->ctx,ID.s,NULL,T.l); $$=T; printcontext(&auxil->ctx);}
             / _ '?' EQUAL T:term {struct type *t; printtype(t=infertype(T.l,&auxil->ctx)); $$=T;}
term        <- (T:application / T:abstraction / T:typeappl / T:typeabstr) {$$=T;}
abstraction <- LAMBDA ID:ID OF TID:tterm {if (indexof(&auxil->db,ID.s)) PCC_ERROR(auxil); debruijn_push(&auxil->db,ID.s);} #forced Church style to allow type inference
                            DOT T:term {
                                        debruijn_pop(&auxil->db);
                                        $$.l=(struct lambda *)malloc(sizeof(struct lambda));
                                        if (!$$.l) PCC_ERROR(auxil);
                                        $$.l->t=LAMBDA_ABSTR;
                                        $$.l->abstr.v=ID.s;
                                        $$.l->abstr.type=TID.t;
                                        $$.l->abstr.expr=T.l;
                                      }
application <- S:application T:atom {
                                        $$.l=(struct lambda *)malloc(sizeof(struct lambda));
                                        if (!$$.l) PCC_ERROR(auxil);
                                        $$.l->t=LAMBDA_APPL;
                                        $$.l->appl.lhs=S.l;
                                        $$.l->appl.rhs=T.l;
                                    }
             / T: atom {$$=T;}
typeappl    <- T:term LB TT:tterm RB
typeabstr   <- UCLAMBDA ID:ID (OF K:tkind)? DOT T:term
atom        <- ID:ID {
                        $$.l=(struct lambda *)malloc(sizeof(struct lambda));
                        if (!$$.l) PCC_ERROR(auxil);
                        $$.l->t=LAMBDA_ATOM;
                        $$.l->atom.s=ID.s;
                        $$.l->atom.index=indexof(&auxil->db,ID.s);
                     }
             / LP T:term RP {$$=T;}
ID          <- _ <[A-Za-z_+][A-Za-z0-9_+]*> _ {
                                                $$.s=strdup($1);
                                                if (!$$.s) PCC_ERROR(auxil);
                                              }
tkind       <- UKIND
tterm       <- T:tatom {$$=T;} (ARROW S:tterm {$$.t=type_function(T.t,S.t);})?
tatom       <- ID:ID {
                    $$.t=mktype(TYPE_NAME,ID.s,0);
                    if (!$$.t) PCC_ERROR(auxil);
                }
             / LP T:tterm RP {$$=T;}
             / FORALL ID:ID (OF K:tkind)? DOT T:tterm
UCLAMBDA    <- _ ('/\\' / '\u039b') _
UKIND       <- _ '*' _
FORALL      <- _ ('\\/' / '\u2200') _
SEP         <- _ ';' _
EQUAL       <- _ '=' _
ARROW       <- _ ('->' / '\u2192') _
LAMBDA      <- _ ('\\' / '\u03bb') _
OF          <- _ ':' _
DOT         <- _ '.' _
LP          <- _ '(' _
RP          <- _ ')' _
LB          <- _ '[' _
RB          <- _ ']' _
_           <- [\n\t\r ]*

